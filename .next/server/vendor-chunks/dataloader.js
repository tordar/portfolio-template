"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dataloader";
exports.ids = ["vendor-chunks/dataloader"];
exports.modules = {

/***/ "(rsc)/./node_modules/dataloader/index.js":
/*!******************************************!*\
  !*** ./node_modules/dataloader/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */\nvar DataLoader =\n/*#__PURE__*/\nfunction () {\n  function DataLoader(batchLoadFn, options) {\n    if (typeof batchLoadFn !== 'function') {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n    this.name = getValidName(options);\n  } // Private\n\n\n  var _proto = DataLoader.prototype;\n\n  /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */\n  _proto.load = function load(key) {\n    if (key === null || key === undefined) {\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\n    }\n\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n    var cacheKey; // If caching and there is a cache-hit, return cached Promise.\n\n    if (cacheMap) {\n      cacheKey = this._cacheKeyFn(key);\n      var cachedPromise = cacheMap.get(cacheKey);\n\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function (resolve) {\n          cacheHits.push(function () {\n            resolve(cachedPromise);\n          });\n        });\n      }\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\n    // dispatched along with the current batch.\n\n\n    batch.keys.push(key);\n    var promise = new Promise(function (resolve, reject) {\n      batch.callbacks.push({\n        resolve: resolve,\n        reject: reject\n      });\n    }); // If caching, cache this promise.\n\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n\n    return promise;\n  }\n  /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */\n  ;\n\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\n    } // Support ArrayLike by using only minimal property access\n\n\n    var loadPromises = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\n        return error;\n      }));\n    }\n\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      cacheMap[\"delete\"](cacheKey);\n    }\n\n    return this;\n  }\n  /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */\n  ;\n\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */\n  ;\n\n  _proto.prime = function prime(key, value) {\n    var cacheMap = this._cacheMap;\n\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n\n\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n\n        if (value instanceof Error) {\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n\n          promise[\"catch\"](function () {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The name given to this `DataLoader` instance. Useful for APM tools.\n   *\n   * Is `null` if not set in the constructor.\n   */\n  ;\n\n  return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\n\n\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n\n  resolvedPromise.then(function () {\n    process.nextTick(fn);\n  });\n} : typeof setImmediate === 'function' ? function (fn) {\n  setImmediate(fn);\n} : function (fn) {\n  setTimeout(fn);\n}; // Private: cached resolved Promise instance\n\nvar resolvedPromise; // Private: Describes a batch of requests\n\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n    return existingBatch;\n  } // Otherwise, create a new batch for this loader.\n\n\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  }; // Store it on the loader so it may be reused.\n\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n\n  loader._batchScheduleFn(function () {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n\nfunction dispatchBatch(loader, batch) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n\n\n  var batchPromise;\n\n  try {\n    batchPromise = loader._batchLoadFn(batch.keys);\n  } catch (e) {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function ' + (\"errored synchronously: \" + String(e) + \".\")));\n  } // Assert the expected response from batchLoadFn\n\n\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  } // Await the resolution of the call to batchLoadFn.\n\n\n  batchPromise.then(function (values) {\n    // Assert the expected resolution from batchLoadFn.\n    if (!isArrayLike(values)) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n\n    if (values.length !== batch.keys.length) {\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\n\n\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var _value = values[i];\n\n      if (_value instanceof Error) {\n        batch.callbacks[i].reject(_value);\n      } else {\n        batch.callbacks[i].resolve(_value);\n      }\n    }\n  })[\"catch\"](function (error) {\n    failedDispatch(loader, batch, error);\n  });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\n\n\nfunction failedDispatch(loader, batch, error) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n} // Private: Resolves the Promises for any cache hits in this batch.\n\n\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n} // Private: given the DataLoader's options, produce a valid max batch size.\n\n\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n\n  if (!shouldBatch) {\n    return 1;\n  }\n\n  var maxBatchSize = options && options.maxBatchSize;\n\n  if (maxBatchSize === undefined) {\n    return Infinity;\n  }\n\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n\n  return maxBatchSize;\n} // Private\n\n\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n\n  if (batchScheduleFn === undefined) {\n    return enqueuePostPromiseJob;\n  }\n\n  if (typeof batchScheduleFn !== 'function') {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n\n  return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\n\n\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n\n  if (cacheKeyFn === undefined) {\n    return function (key) {\n      return key;\n    };\n  }\n\n  if (typeof cacheKeyFn !== 'function') {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n\n  return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\n\n\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n\n  if (!shouldCache) {\n    return null;\n  }\n\n  var cacheMap = options && options.cacheMap;\n\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\n    });\n\n    if (missingFunctions.length !== 0) {\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\n    }\n  }\n\n  return cacheMap;\n}\n\nfunction getValidName(options) {\n  if (options && options.name) {\n    return options.name;\n  }\n\n  return null;\n} // Private\n\n\nfunction isArrayLike(x) {\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\n\nmodule.exports = DataLoader;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGF0YWxvYWRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7O0FBRzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBLHlDQUF5QztBQUN6QyxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBLEdBQUc7O0FBRUgscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOLDZCQUE2Qjs7QUFFN0Isb0JBQW9CLDRCQUE0QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdG9yZGFydG9tbWVydmlrL0RvY3VtZW50cy9jb2RlL3BvcnRmb2xpby0yNC10ZW1wbGF0ZS9ub2RlX21vZHVsZXMvZGF0YWxvYWRlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCwgR3JhcGhRTCBGb3VuZGF0aW9uXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIEEgRnVuY3Rpb24sIHdoaWNoIHdoZW4gZ2l2ZW4gYW4gQXJyYXkgb2Yga2V5cywgcmV0dXJucyBhIFByb21pc2Ugb2YgYW4gQXJyYXlcbi8vIG9mIHZhbHVlcyBvciBFcnJvcnMuXG4vLyBPcHRpb25hbGx5IHR1cm4gb2ZmIGJhdGNoaW5nIG9yIGNhY2hpbmcgb3IgcHJvdmlkZSBhIGNhY2hlIGtleSBmdW5jdGlvbiBvciBhXG4vLyBjdXN0b20gY2FjaGUgaW5zdGFuY2UuXG4vLyBJZiBhIGN1c3RvbSBjYWNoZSBpcyBwcm92aWRlZCwgaXQgbXVzdCBiZSBvZiB0aGlzIHR5cGUgKGEgc3Vic2V0IG9mIEVTNiBNYXApLlxuXG4vKipcbiAqIEEgYERhdGFMb2FkZXJgIGNyZWF0ZXMgYSBwdWJsaWMgQVBJIGZvciBsb2FkaW5nIGRhdGEgZnJvbSBhIHBhcnRpY3VsYXJcbiAqIGRhdGEgYmFjay1lbmQgd2l0aCB1bmlxdWUga2V5cyBzdWNoIGFzIHRoZSBgaWRgIGNvbHVtbiBvZiBhIFNRTCB0YWJsZSBvclxuICogZG9jdW1lbnQgbmFtZSBpbiBhIE1vbmdvREIgZGF0YWJhc2UsIGdpdmVuIGEgYmF0Y2ggbG9hZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFYWNoIGBEYXRhTG9hZGVyYCBpbnN0YW5jZSBjb250YWlucyBhIHVuaXF1ZSBtZW1vaXplZCBjYWNoZS4gVXNlIGNhdXRpb24gd2hlblxuICogdXNlZCBpbiBsb25nLWxpdmVkIGFwcGxpY2F0aW9ucyBvciB0aG9zZSB3aGljaCBzZXJ2ZSBtYW55IHVzZXJzIHdpdGhcbiAqIGRpZmZlcmVudCBhY2Nlc3MgcGVybWlzc2lvbnMgYW5kIGNvbnNpZGVyIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlIHBlclxuICogd2ViIHJlcXVlc3QuXG4gKi9cbnZhciBEYXRhTG9hZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YUxvYWRlcihiYXRjaExvYWRGbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgYmF0Y2hMb2FkRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGFMb2FkZXIgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyAnICsgKFwiQXJyYXk8a2V5PiBhbmQgcmV0dXJucyBQcm9taXNlPEFycmF5PHZhbHVlPj4sIGJ1dCBnb3Q6IFwiICsgYmF0Y2hMb2FkRm4gKyBcIi5cIikpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhdGNoTG9hZEZuID0gYmF0Y2hMb2FkRm47XG4gICAgdGhpcy5fbWF4QmF0Y2hTaXplID0gZ2V0VmFsaWRNYXhCYXRjaFNpemUob3B0aW9ucyk7XG4gICAgdGhpcy5fYmF0Y2hTY2hlZHVsZUZuID0gZ2V0VmFsaWRCYXRjaFNjaGVkdWxlRm4ob3B0aW9ucyk7XG4gICAgdGhpcy5fY2FjaGVLZXlGbiA9IGdldFZhbGlkQ2FjaGVLZXlGbihvcHRpb25zKTtcbiAgICB0aGlzLl9jYWNoZU1hcCA9IGdldFZhbGlkQ2FjaGVNYXAob3B0aW9ucyk7XG4gICAgdGhpcy5fYmF0Y2ggPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IGdldFZhbGlkTmFtZShvcHRpb25zKTtcbiAgfSAvLyBQcml2YXRlXG5cblxuICB2YXIgX3Byb3RvID0gRGF0YUxvYWRlci5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIExvYWRzIGEga2V5LCByZXR1cm5pbmcgYSBgUHJvbWlzZWAgZm9yIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGF0IGtleS5cbiAgICovXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbG9hZGVyLmxvYWQoKSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgdmFsdWUsICcgKyAoXCJidXQgZ290OiBcIiArIFN0cmluZyhrZXkpICsgXCIuXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgYmF0Y2ggPSBnZXRDdXJyZW50QmF0Y2godGhpcyk7XG4gICAgdmFyIGNhY2hlTWFwID0gdGhpcy5fY2FjaGVNYXA7XG4gICAgdmFyIGNhY2hlS2V5OyAvLyBJZiBjYWNoaW5nIGFuZCB0aGVyZSBpcyBhIGNhY2hlLWhpdCwgcmV0dXJuIGNhY2hlZCBQcm9taXNlLlxuXG4gICAgaWYgKGNhY2hlTWFwKSB7XG4gICAgICBjYWNoZUtleSA9IHRoaXMuX2NhY2hlS2V5Rm4oa2V5KTtcbiAgICAgIHZhciBjYWNoZWRQcm9taXNlID0gY2FjaGVNYXAuZ2V0KGNhY2hlS2V5KTtcblxuICAgICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgICAgdmFyIGNhY2hlSGl0cyA9IGJhdGNoLmNhY2hlSGl0cyB8fCAoYmF0Y2guY2FjaGVIaXRzID0gW10pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBjYWNoZUhpdHMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKGNhY2hlZFByb21pc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIE90aGVyd2lzZSwgcHJvZHVjZSBhIG5ldyBQcm9taXNlIGZvciB0aGlzIGtleSwgYW5kIGVucXVldWUgaXQgdG8gYmVcbiAgICAvLyBkaXNwYXRjaGVkIGFsb25nIHdpdGggdGhlIGN1cnJlbnQgYmF0Y2guXG5cblxuICAgIGJhdGNoLmtleXMucHVzaChrZXkpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYmF0Y2guY2FsbGJhY2tzLnB1c2goe1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgfSk7XG4gICAgfSk7IC8vIElmIGNhY2hpbmcsIGNhY2hlIHRoaXMgcHJvbWlzZS5cblxuICAgIGlmIChjYWNoZU1hcCkge1xuICAgICAgY2FjaGVNYXAuc2V0KGNhY2hlS2V5LCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogTG9hZHMgbXVsdGlwbGUga2V5cywgcHJvbWlzaW5nIGFuIGFycmF5IG9mIHZhbHVlczpcbiAgICpcbiAgICogICAgIHZhciBbIGEsIGIgXSA9IGF3YWl0IG15TG9hZGVyLmxvYWRNYW55KFsgJ2EnLCAnYicgXSk7XG4gICAqXG4gICAqIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgbW9yZSB2ZXJib3NlOlxuICAgKlxuICAgKiAgICAgdmFyIFsgYSwgYiBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgKiAgICAgICBteUxvYWRlci5sb2FkKCdhJyksXG4gICAqICAgICAgIG15TG9hZGVyLmxvYWQoJ2InKVxuICAgKiAgICAgXSk7XG4gICAqXG4gICAqIEhvd2V2ZXIgaXQgaXMgZGlmZmVyZW50IGluIHRoZSBjYXNlIHdoZXJlIGFueSBsb2FkIGZhaWxzLiBXaGVyZVxuICAgKiBQcm9taXNlLmFsbCgpIHdvdWxkIHJlamVjdCwgbG9hZE1hbnkoKSBhbHdheXMgcmVzb2x2ZXMsIGhvd2V2ZXIgZWFjaCByZXN1bHRcbiAgICogaXMgZWl0aGVyIGEgdmFsdWUgb3IgYW4gRXJyb3IgaW5zdGFuY2UuXG4gICAqXG4gICAqICAgICB2YXIgWyBhLCBiLCBjIF0gPSBhd2FpdCBteUxvYWRlci5sb2FkTWFueShbICdhJywgJ2InLCAnYmFka2V5JyBdKTtcbiAgICogICAgIC8vIGMgaW5zdGFuY2VvZiBFcnJvclxuICAgKlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5sb2FkTWFueSA9IGZ1bmN0aW9uIGxvYWRNYW55KGtleXMpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKGtleXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbG9hZGVyLmxvYWRNYW55KCkgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgd2l0aCBBcnJheTxrZXk+ICcgKyAoXCJidXQgZ290OiBcIiArIGtleXMgKyBcIi5cIikpO1xuICAgIH0gLy8gU3VwcG9ydCBBcnJheUxpa2UgYnkgdXNpbmcgb25seSBtaW5pbWFsIHByb3BlcnR5IGFjY2Vzc1xuXG5cbiAgICB2YXIgbG9hZFByb21pc2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvYWRQcm9taXNlcy5wdXNoKHRoaXMubG9hZChrZXlzW2ldKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRQcm9taXNlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgdmFsdWUgYXQgYGtleWAgZnJvbSB0aGUgY2FjaGUsIGlmIGl0IGV4aXN0cy4gUmV0dXJucyBpdHNlbGYgZm9yXG4gICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihrZXkpIHtcbiAgICB2YXIgY2FjaGVNYXAgPSB0aGlzLl9jYWNoZU1hcDtcblxuICAgIGlmIChjYWNoZU1hcCkge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy5fY2FjaGVLZXlGbihrZXkpO1xuXG4gICAgICBjYWNoZU1hcFtcImRlbGV0ZVwiXShjYWNoZUtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgZW50aXJlIGNhY2hlLiBUbyBiZSB1c2VkIHdoZW4gc29tZSBldmVudCByZXN1bHRzIGluIHVua25vd25cbiAgICogaW52YWxpZGF0aW9ucyBhY3Jvc3MgdGhpcyBwYXJ0aWN1bGFyIGBEYXRhTG9hZGVyYC4gUmV0dXJucyBpdHNlbGYgZm9yXG4gICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2xlYXJBbGwgPSBmdW5jdGlvbiBjbGVhckFsbCgpIHtcbiAgICB2YXIgY2FjaGVNYXAgPSB0aGlzLl9jYWNoZU1hcDtcblxuICAgIGlmIChjYWNoZU1hcCkge1xuICAgICAgY2FjaGVNYXAuY2xlYXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyB0aGUgcHJvdmlkZWQga2V5IGFuZCB2YWx1ZSB0byB0aGUgY2FjaGUuIElmIHRoZSBrZXkgYWxyZWFkeVxuICAgKiBleGlzdHMsIG5vIGNoYW5nZSBpcyBtYWRlLiBSZXR1cm5zIGl0c2VsZiBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKlxuICAgKiBUbyBwcmltZSB0aGUgY2FjaGUgd2l0aCBhbiBlcnJvciBhdCBhIGtleSwgcHJvdmlkZSBhbiBFcnJvciBpbnN0YW5jZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHJpbWUgPSBmdW5jdGlvbiBwcmltZShrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlTWFwID0gdGhpcy5fY2FjaGVNYXA7XG5cbiAgICBpZiAoY2FjaGVNYXApIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMuX2NhY2hlS2V5Rm4oa2V5KTsgLy8gT25seSBhZGQgdGhlIGtleSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuXG5cbiAgICAgIGlmIChjYWNoZU1hcC5nZXQoY2FjaGVLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ2FjaGUgYSByZWplY3RlZCBwcm9taXNlIGlmIHRoZSB2YWx1ZSBpcyBhbiBFcnJvciwgaW4gb3JkZXIgdG8gbWF0Y2hcbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIG9mIGxvYWQoa2V5KS5cbiAgICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QodmFsdWUpOyAvLyBTaW5jZSB0aGlzIGlzIGEgY2FzZSB3aGVyZSBhbiBFcnJvciBpcyBpbnRlbnRpb25hbGx5IGJlaW5nIHByaW1lZFxuICAgICAgICAgIC8vIGZvciBhIGdpdmVuIGtleSwgd2Ugd2FudCB0byBkaXNhYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbi5cblxuICAgICAgICAgIHByb21pc2VbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWNoZU1hcC5zZXQoY2FjaGVLZXksIHByb21pc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBnaXZlbiB0byB0aGlzIGBEYXRhTG9hZGVyYCBpbnN0YW5jZS4gVXNlZnVsIGZvciBBUE0gdG9vbHMuXG4gICAqXG4gICAqIElzIGBudWxsYCBpZiBub3Qgc2V0IGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIDtcblxuICByZXR1cm4gRGF0YUxvYWRlcjtcbn0oKTsgLy8gUHJpdmF0ZTogRW5xdWV1ZSBhIEpvYiB0byBiZSBleGVjdXRlZCBhZnRlciBhbGwgXCJQcm9taXNlSm9ic1wiIEpvYnMuXG4vL1xuLy8gRVM2IEphdmFTY3JpcHQgdXNlcyB0aGUgY29uY2VwdHMgSm9iIGFuZCBKb2JRdWV1ZSB0byBzY2hlZHVsZSB3b3JrIHRvIG9jY3VyXG4vLyBhZnRlciB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dCBoYXMgY29tcGxldGVkOlxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWpvYnMtYW5kLWpvYi1xdWV1ZXNcbi8vXG4vLyBOb2RlLmpzIHVzZXMgdGhlIGBwcm9jZXNzLm5leHRUaWNrYCBtZWNoYW5pc20gdG8gaW1wbGVtZW50IHRoZSBjb25jZXB0IG9mIGFcbi8vIEpvYiwgbWFpbnRhaW5pbmcgYSBnbG9iYWwgRklGTyBKb2JRdWV1ZSBmb3IgYWxsIEpvYnMsIHdoaWNoIGlzIGZsdXNoZWQgYWZ0ZXJcbi8vIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgZW5kcy5cbi8vXG4vLyBXaGVuIGNhbGxpbmcgYHRoZW5gIG9uIGEgUHJvbWlzZSwgaXQgZW5xdWV1ZXMgYSBKb2Igb24gYSBzcGVjaWZpY1xuLy8gXCJQcm9taXNlSm9ic1wiIEpvYlF1ZXVlIHdoaWNoIGlzIGZsdXNoZWQgaW4gTm9kZSBhcyBhIHNpbmdsZSBKb2Igb24gdGhlXG4vLyBnbG9iYWwgSm9iUXVldWUuXG4vL1xuLy8gRGF0YUxvYWRlciBiYXRjaGVzIGFsbCBsb2FkcyB3aGljaCBvY2N1ciBpbiBhIHNpbmdsZSBmcmFtZSBvZiBleGVjdXRpb24sIGJ1dFxuLy8gc2hvdWxkIGluY2x1ZGUgaW4gdGhlIGJhdGNoIGFsbCBsb2FkcyB3aGljaCBvY2N1ciBkdXJpbmcgdGhlIGZsdXNoaW5nIG9mIHRoZVxuLy8gXCJQcm9taXNlSm9ic1wiIEpvYlF1ZXVlIGFmdGVyIHRoYXQgc2FtZSBleGVjdXRpb24gZnJhbWUuXG4vL1xuLy8gSW4gb3JkZXIgdG8gYXZvaWQgdGhlIERhdGFMb2FkZXIgZGlzcGF0Y2ggSm9iIG9jY3VyaW5nIGJlZm9yZSBcIlByb21pc2VKb2JzXCIsXG4vLyBBIFByb21pc2UgSm9iIGlzIGNyZWF0ZWQgd2l0aCB0aGUgc29sZSBwdXJwb3NlIG9mIGVucXVldWluZyBhIGdsb2JhbCBKb2IsXG4vLyBlbnN1cmluZyB0aGF0IGl0IGFsd2F5cyBvY2N1cnMgYWZ0ZXIgXCJQcm9taXNlSm9ic1wiIGVuZHMuXG4vL1xuLy8gTm9kZS5qcydzIGpvYiBxdWV1ZSBpcyB1bmlxdWUuIEJyb3dzZXJzIGRvIG5vdCBoYXZlIGFuIGVxdWl2YWxlbnQgbWVjaGFuaXNtXG4vLyBmb3IgZW5xdWV1aW5nIGEgam9iIHRvIGJlIHBlcmZvcm1lZCBhZnRlciBwcm9taXNlIG1pY3JvdGFza3MgYW5kIGJlZm9yZSB0aGVcbi8vIG5leHQgbWFjcm90YXNrLiBGb3IgYnJvd3NlciBlbnZpcm9ubWVudHMsIGEgbWFjcm90YXNrIGlzIHVzZWQgKHZpYVxuLy8gc2V0SW1tZWRpYXRlIG9yIHNldFRpbWVvdXQpIGF0IGEgcG90ZW50aWFsIHBlcmZvcm1hbmNlIHBlbmFsdHkuXG5cblxudmFyIGVucXVldWVQb3N0UHJvbWlzZUpvYiA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIChmbikge1xuICBpZiAoIXJlc29sdmVkUHJvbWlzZSkge1xuICAgIHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICB9KTtcbn0gOiB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gKGZuKSB7XG4gIHNldEltbWVkaWF0ZShmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHNldFRpbWVvdXQoZm4pO1xufTsgLy8gUHJpdmF0ZTogY2FjaGVkIHJlc29sdmVkIFByb21pc2UgaW5zdGFuY2VcblxudmFyIHJlc29sdmVkUHJvbWlzZTsgLy8gUHJpdmF0ZTogRGVzY3JpYmVzIGEgYmF0Y2ggb2YgcmVxdWVzdHNcblxuLy8gUHJpdmF0ZTogRWl0aGVyIHJldHVybnMgdGhlIGN1cnJlbnQgYmF0Y2gsIG9yIGNyZWF0ZXMgYW5kIHNjaGVkdWxlcyBhXG4vLyBkaXNwYXRjaCBvZiBhIG5ldyBiYXRjaCBmb3IgdGhlIGdpdmVuIGxvYWRlci5cbmZ1bmN0aW9uIGdldEN1cnJlbnRCYXRjaChsb2FkZXIpIHtcbiAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgYmF0Y2ggd2hpY2ggaGFzIG5vdCB5ZXQgZGlzcGF0Y2hlZCBhbmQgaXMgd2l0aGluXG4gIC8vIHRoZSBsaW1pdCBvZiB0aGUgYmF0Y2ggc2l6ZSwgdGhlbiByZXR1cm4gaXQuXG4gIHZhciBleGlzdGluZ0JhdGNoID0gbG9hZGVyLl9iYXRjaDtcblxuICBpZiAoZXhpc3RpbmdCYXRjaCAhPT0gbnVsbCAmJiAhZXhpc3RpbmdCYXRjaC5oYXNEaXNwYXRjaGVkICYmIGV4aXN0aW5nQmF0Y2gua2V5cy5sZW5ndGggPCBsb2FkZXIuX21heEJhdGNoU2l6ZSkge1xuICAgIHJldHVybiBleGlzdGluZ0JhdGNoO1xuICB9IC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IGJhdGNoIGZvciB0aGlzIGxvYWRlci5cblxuXG4gIHZhciBuZXdCYXRjaCA9IHtcbiAgICBoYXNEaXNwYXRjaGVkOiBmYWxzZSxcbiAgICBrZXlzOiBbXSxcbiAgICBjYWxsYmFja3M6IFtdXG4gIH07IC8vIFN0b3JlIGl0IG9uIHRoZSBsb2FkZXIgc28gaXQgbWF5IGJlIHJldXNlZC5cblxuICBsb2FkZXIuX2JhdGNoID0gbmV3QmF0Y2g7IC8vIFRoZW4gc2NoZWR1bGUgYSB0YXNrIHRvIGRpc3BhdGNoIHRoaXMgYmF0Y2ggb2YgcmVxdWVzdHMuXG5cbiAgbG9hZGVyLl9iYXRjaFNjaGVkdWxlRm4oZnVuY3Rpb24gKCkge1xuICAgIGRpc3BhdGNoQmF0Y2gobG9hZGVyLCBuZXdCYXRjaCk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXdCYXRjaDtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hCYXRjaChsb2FkZXIsIGJhdGNoKSB7XG4gIC8vIE1hcmsgdGhpcyBiYXRjaCBhcyBoYXZpbmcgYmVlbiBkaXNwYXRjaGVkLlxuICBiYXRjaC5oYXNEaXNwYXRjaGVkID0gdHJ1ZTsgLy8gSWYgdGhlcmUncyBub3RoaW5nIHRvIGxvYWQsIHJlc29sdmUgYW55IGNhY2hlIGhpdHMgYW5kIHJldHVybiBlYXJseS5cblxuICBpZiAoYmF0Y2gua2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXNvbHZlQ2FjaGVIaXRzKGJhdGNoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gQ2FsbCB0aGUgcHJvdmlkZWQgYmF0Y2hMb2FkRm4gZm9yIHRoaXMgbG9hZGVyIHdpdGggdGhlIGJhdGNoJ3Mga2V5cyBhbmRcbiAgLy8gd2l0aCB0aGUgbG9hZGVyIGFzIHRoZSBgdGhpc2AgY29udGV4dC5cblxuXG4gIHZhciBiYXRjaFByb21pc2U7XG5cbiAgdHJ5IHtcbiAgICBiYXRjaFByb21pc2UgPSBsb2FkZXIuX2JhdGNoTG9hZEZuKGJhdGNoLmtleXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhaWxlZERpc3BhdGNoKGxvYWRlciwgYmF0Y2gsIG5ldyBUeXBlRXJyb3IoJ0RhdGFMb2FkZXIgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyAnICsgJ0FycmF5PGtleT4gYW5kIHJldHVybnMgUHJvbWlzZTxBcnJheTx2YWx1ZT4+LCBidXQgdGhlIGZ1bmN0aW9uICcgKyAoXCJlcnJvcmVkIHN5bmNocm9ub3VzbHk6IFwiICsgU3RyaW5nKGUpICsgXCIuXCIpKSk7XG4gIH0gLy8gQXNzZXJ0IHRoZSBleHBlY3RlZCByZXNwb25zZSBmcm9tIGJhdGNoTG9hZEZuXG5cblxuICBpZiAoIWJhdGNoUHJvbWlzZSB8fCB0eXBlb2YgYmF0Y2hQcm9taXNlLnRoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFpbGVkRGlzcGF0Y2gobG9hZGVyLCBiYXRjaCwgbmV3IFR5cGVFcnJvcignRGF0YUxvYWRlciBtdXN0IGJlIGNvbnN0cnVjdGVkIHdpdGggYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzICcgKyAnQXJyYXk8a2V5PiBhbmQgcmV0dXJucyBQcm9taXNlPEFycmF5PHZhbHVlPj4sIGJ1dCB0aGUgZnVuY3Rpb24gZGlkICcgKyAoXCJub3QgcmV0dXJuIGEgUHJvbWlzZTogXCIgKyBTdHJpbmcoYmF0Y2hQcm9taXNlKSArIFwiLlwiKSkpO1xuICB9IC8vIEF3YWl0IHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYWxsIHRvIGJhdGNoTG9hZEZuLlxuXG5cbiAgYmF0Y2hQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIC8vIEFzc2VydCB0aGUgZXhwZWN0ZWQgcmVzb2x1dGlvbiBmcm9tIGJhdGNoTG9hZEZuLlxuICAgIGlmICghaXNBcnJheUxpa2UodmFsdWVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YUxvYWRlciBtdXN0IGJlIGNvbnN0cnVjdGVkIHdpdGggYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzICcgKyAnQXJyYXk8a2V5PiBhbmQgcmV0dXJucyBQcm9taXNlPEFycmF5PHZhbHVlPj4sIGJ1dCB0aGUgZnVuY3Rpb24gZGlkICcgKyAoXCJub3QgcmV0dXJuIGEgUHJvbWlzZSBvZiBhbiBBcnJheTogXCIgKyBTdHJpbmcodmFsdWVzKSArIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGJhdGNoLmtleXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhTG9hZGVyIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgJyArICdBcnJheTxrZXk+IGFuZCByZXR1cm5zIFByb21pc2U8QXJyYXk8dmFsdWU+PiwgYnV0IHRoZSBmdW5jdGlvbiBkaWQgJyArICdub3QgcmV0dXJuIGEgUHJvbWlzZSBvZiBhbiBBcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIEFycmF5ICcgKyAnb2Yga2V5cy4nICsgKFwiXFxuXFxuS2V5czpcXG5cIiArIFN0cmluZyhiYXRjaC5rZXlzKSkgKyAoXCJcXG5cXG5WYWx1ZXM6XFxuXCIgKyBTdHJpbmcodmFsdWVzKSkpO1xuICAgIH0gLy8gUmVzb2x2ZSBhbGwgY2FjaGUgaGl0cyBpbiB0aGUgc2FtZSBtaWNyby10YXNrIGFzIGZyZXNobHkgbG9hZGVkIHZhbHVlcy5cblxuXG4gICAgcmVzb2x2ZUNhY2hlSGl0cyhiYXRjaCk7IC8vIFN0ZXAgdGhyb3VnaCB2YWx1ZXMsIHJlc29sdmluZyBvciByZWplY3RpbmcgZWFjaCBQcm9taXNlIGluIHRoZSBiYXRjaC5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2guY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3ZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICBpZiAoX3ZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgYmF0Y2guY2FsbGJhY2tzW2ldLnJlamVjdChfdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2guY2FsbGJhY2tzW2ldLnJlc29sdmUoX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgZmFpbGVkRGlzcGF0Y2gobG9hZGVyLCBiYXRjaCwgZXJyb3IpO1xuICB9KTtcbn0gLy8gUHJpdmF0ZTogZG8gbm90IGNhY2hlIGluZGl2aWR1YWwgbG9hZHMgaWYgdGhlIGVudGlyZSBiYXRjaCBkaXNwYXRjaCBmYWlscyxcbi8vIGJ1dCBzdGlsbCByZWplY3QgZWFjaCByZXF1ZXN0IHNvIHRoZXkgZG8gbm90IGhhbmcuXG5cblxuZnVuY3Rpb24gZmFpbGVkRGlzcGF0Y2gobG9hZGVyLCBiYXRjaCwgZXJyb3IpIHtcbiAgLy8gQ2FjaGUgaGl0cyBhcmUgcmVzb2x2ZWQsIGV2ZW4gdGhvdWdoIHRoZSBiYXRjaCBmYWlsZWQuXG4gIHJlc29sdmVDYWNoZUhpdHMoYmF0Y2gpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2gua2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGxvYWRlci5jbGVhcihiYXRjaC5rZXlzW2ldKTtcbiAgICBiYXRjaC5jYWxsYmFja3NbaV0ucmVqZWN0KGVycm9yKTtcbiAgfVxufSAvLyBQcml2YXRlOiBSZXNvbHZlcyB0aGUgUHJvbWlzZXMgZm9yIGFueSBjYWNoZSBoaXRzIGluIHRoaXMgYmF0Y2guXG5cblxuZnVuY3Rpb24gcmVzb2x2ZUNhY2hlSGl0cyhiYXRjaCkge1xuICBpZiAoYmF0Y2guY2FjaGVIaXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaC5jYWNoZUhpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhdGNoLmNhY2hlSGl0c1tpXSgpO1xuICAgIH1cbiAgfVxufSAvLyBQcml2YXRlOiBnaXZlbiB0aGUgRGF0YUxvYWRlcidzIG9wdGlvbnMsIHByb2R1Y2UgYSB2YWxpZCBtYXggYmF0Y2ggc2l6ZS5cblxuXG5mdW5jdGlvbiBnZXRWYWxpZE1heEJhdGNoU2l6ZShvcHRpb25zKSB7XG4gIHZhciBzaG91bGRCYXRjaCA9ICFvcHRpb25zIHx8IG9wdGlvbnMuYmF0Y2ggIT09IGZhbHNlO1xuXG4gIGlmICghc2hvdWxkQmF0Y2gpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBtYXhCYXRjaFNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMubWF4QmF0Y2hTaXplO1xuXG4gIGlmIChtYXhCYXRjaFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWF4QmF0Y2hTaXplICE9PSAnbnVtYmVyJyB8fCBtYXhCYXRjaFNpemUgPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1heEJhdGNoU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyOiBcIiArIG1heEJhdGNoU2l6ZSk7XG4gIH1cblxuICByZXR1cm4gbWF4QmF0Y2hTaXplO1xufSAvLyBQcml2YXRlXG5cblxuZnVuY3Rpb24gZ2V0VmFsaWRCYXRjaFNjaGVkdWxlRm4ob3B0aW9ucykge1xuICB2YXIgYmF0Y2hTY2hlZHVsZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLmJhdGNoU2NoZWR1bGVGbjtcblxuICBpZiAoYmF0Y2hTY2hlZHVsZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZW5xdWV1ZVBvc3RQcm9taXNlSm9iO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiYXRjaFNjaGVkdWxlRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYmF0Y2hTY2hlZHVsZUZuIG11c3QgYmUgYSBmdW5jdGlvbjogXCIgKyBiYXRjaFNjaGVkdWxlRm4pO1xuICB9XG5cbiAgcmV0dXJuIGJhdGNoU2NoZWR1bGVGbjtcbn0gLy8gUHJpdmF0ZTogZ2l2ZW4gdGhlIERhdGFMb2FkZXIncyBvcHRpb25zLCBwcm9kdWNlIGEgY2FjaGUga2V5IGZ1bmN0aW9uLlxuXG5cbmZ1bmN0aW9uIGdldFZhbGlkQ2FjaGVLZXlGbihvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlS2V5Rm47XG5cbiAgaWYgKGNhY2hlS2V5Rm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGNhY2hlS2V5Rm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FjaGVLZXlGbiBtdXN0IGJlIGEgZnVuY3Rpb246IFwiICsgY2FjaGVLZXlGbik7XG4gIH1cblxuICByZXR1cm4gY2FjaGVLZXlGbjtcbn0gLy8gUHJpdmF0ZTogZ2l2ZW4gdGhlIERhdGFMb2FkZXIncyBvcHRpb25zLCBwcm9kdWNlIGEgQ2FjaGVNYXAgdG8gYmUgdXNlZC5cblxuXG5mdW5jdGlvbiBnZXRWYWxpZENhY2hlTWFwKG9wdGlvbnMpIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5jYWNoZSAhPT0gZmFsc2U7XG5cbiAgaWYgKCFzaG91bGRDYWNoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNhY2hlTWFwID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlTWFwO1xuXG4gIGlmIChjYWNoZU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgfVxuXG4gIGlmIChjYWNoZU1hcCAhPT0gbnVsbCkge1xuICAgIHZhciBjYWNoZUZ1bmN0aW9ucyA9IFsnZ2V0JywgJ3NldCcsICdkZWxldGUnLCAnY2xlYXInXTtcbiAgICB2YXIgbWlzc2luZ0Z1bmN0aW9ucyA9IGNhY2hlRnVuY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgICByZXR1cm4gY2FjaGVNYXAgJiYgdHlwZW9mIGNhY2hlTWFwW2ZuTmFtZV0gIT09ICdmdW5jdGlvbic7XG4gICAgfSk7XG5cbiAgICBpZiAobWlzc2luZ0Z1bmN0aW9ucy5sZW5ndGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0N1c3RvbSBjYWNoZU1hcCBtaXNzaW5nIG1ldGhvZHM6ICcgKyBtaXNzaW5nRnVuY3Rpb25zLmpvaW4oJywgJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYWNoZU1hcDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsaWROYW1lKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubmFtZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBQcml2YXRlXG5cblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJyAmJiAoeC5sZW5ndGggPT09IDAgfHwgeC5sZW5ndGggPiAwICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCB4Lmxlbmd0aCAtIDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTG9hZGVyOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dataloader/index.js\n");

/***/ })

};
;